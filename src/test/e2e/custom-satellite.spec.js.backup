import { test, expect } from "@playwright/test";

/**
 * E2E Test: Custom Satellite Workflow
 *
 * Tests the ability to add custom satellites via TLE input.
 * This is a critical feature for users tracking specific satellites
 * not in the default database.
 *
 * This test prevents regressions in:
 * - Custom TLE input parsing
 * - Satellite creation from user data
 * - Orbit visualization for custom satellites
 */

// Sample valid TLE for testing
const VALID_TLE = `CUSTOM TEST SAT
1 99999U 24001A   24001.50000000  .00001000  00000-0  10000-4 0  9999
2 99999  98.0000 180.0000 0010000 100.0000 260.0000 14.50000000100000`;

const ISS_TLE = `ISS (ZARYA)
1 25544U 98067A   24001.50000000  .00016717  00000-0  10270-3 0  9991
2 25544  51.6416 247.4627 0006703  85.5961 274.6009 15.49478733123456`;

test.describe("Custom Satellite Input", () => {
  test("should add custom satellite from TLE input", async ({ page }) => {
    await page.goto("/");

    // Wait for initialization
    await expect(page.locator("#cesiumContainer canvas").first()).toBeVisible({ timeout: 15000 });

    // Look for custom satellite / add satellite button
    const customSatButton = page.locator('[data-testid="custom-satellite-button"]').or(
      page.locator('button:has-text("Custom")'),
    ).or(
      page.locator('button:has-text("Add Satellite")'),
    ).or(
      page.locator('.custom-satellite-button'),
    ).first();

    // If custom satellite button exists, test the workflow
    if (await customSatButton.isVisible({ timeout: 2000 }).catch(() => false)) {
      await customSatButton.click();

      // Find TLE input textarea
      const tleInput = page.locator('textarea[placeholder*="TLE"]').or(
        page.locator('textarea[name="tle"]'),
      ).or(
        page.locator('textarea').first(),
      );

      await expect(tleInput).toBeVisible();

      // Input custom TLE
      await tleInput.fill(VALID_TLE);

      // Find and click add/submit button
      const submitButton = page.locator('button:has-text("Add")').or(
        page.locator('button[type="submit"]'),
      ).or(
        page.locator('button:has-text("Create")'),
      ).first();

      await submitButton.click();

      // Wait for satellite to be added
      await page.waitForTimeout(1000);

      // Verify satellite appears in the scene or satellite list
      await expect(
        page.locator('text="CUSTOM TEST SAT"').or(
          page.locator('[data-satellite-name*="CUSTOM"]'),
        ).first(),
      ).toBeVisible({ timeout: 5000 });
    } else {
      // Skip test if custom satellite feature not found
      test.skip();
    }
  });

  test("should validate TLE format and show errors for invalid input", async ({ page }) => {
    await page.goto("/");

    await expect(page.locator("#cesiumContainer canvas").first()).toBeVisible({ timeout: 15000 });

    const customSatButton = page.locator('[data-testid="custom-satellite-button"]').or(
      page.locator('button:has-text("Custom")'),
    ).or(
      page.locator('button:has-text("Add Satellite")'),
    ).first();

    if (await customSatButton.isVisible({ timeout: 2000 }).catch(() => false)) {
      await customSatButton.click();

      const tleInput = page.locator('textarea[placeholder*="TLE"]').or(
        page.locator('textarea[name="tle"]'),
      ).or(
        page.locator('textarea').first(),
      );

      await expect(tleInput).toBeVisible();

      // Input invalid TLE (missing second line)
      await tleInput.fill("INVALID SATELLITE\n1 99999U 24001A   24001.50000000  .00001000  00000-0  10000-4 0  9999");

      const submitButton = page.locator('button:has-text("Add")').or(
        page.locator('button[type="submit"]'),
      ).first();

      await submitButton.click();

      // Should show error message
      await expect(
        page.locator('text=/invalid|error/i').or(
          page.locator('.error'),
        ).first(),
      ).toBeVisible({ timeout: 3000 });
    } else {
      test.skip();
    }
  });

  test("should load satellite from TLE URL parameter", async ({ page }) => {
    // Encode TLE in URL parameter (common use case for sharing)
    const tleParam = encodeURIComponent(ISS_TLE);

    await page.goto(`/?tle=${tleParam}`);

    // Wait for initialization
    await expect(page.locator("#cesiumContainer canvas").first()).toBeVisible({ timeout: 15000 });

    await page.waitForTimeout(3000);

    // Verify scene loaded successfully (timeline should be visible)
    const timelineExists = await page.locator('.cesium-timeline-main').isVisible();
    expect(timelineExists).toBeTruthy();

    // Verify no JavaScript errors occurred
    const errors = [];
    page.on("pageerror", (error) => errors.push(error));
    await page.waitForTimeout(1000);
    expect(errors.length).toBe(0);
  });
});

test.describe("Satellite Visualization Controls", () => {
  test("should toggle orbit and orbit track visualization for untracked and tracked satellites", async ({ page }) => {
    // Start with a clean slate - no query parameters
    await page.goto("/");

    await expect(page.locator("#cesiumContainer canvas").first()).toBeVisible({ timeout: 15000 });
    await page.waitForTimeout(2000);

    // Step 1: Select two satellites (ISS and Tiangong) to test both untracked and tracked scenarios
    const satelliteMenuButton = page.locator('button.cesium-toolbar-button').filter({
      has: page.locator('.icon.svg-sat'),
    }).first();

    await expect(satelliteMenuButton).toBeVisible({ timeout: 5000 });
    await satelliteMenuButton.click();
    await page.waitForTimeout(1000);

    // Wait for satellite select to be visible
    await expect(page.locator('.satellite-select')).toBeVisible({ timeout: 5000 });

    // Select ISS
    const multiselectComponent = page.locator('.satellite-select .multiselect').first();
    await multiselectComponent.click();
    await page.waitForTimeout(500);

    const searchInput = page.locator('.satellite-select input[placeholder="Type to search"]').first();
    await searchInput.pressSequentially("ISS", { delay: 100 });
    await page.waitForTimeout(1500);

    const issOption = page.locator('.multiselect__element').filter({
      hasText: /ISS.*ZARYA/i,
    }).first();

    await expect(issOption).toBeVisible({ timeout: 5000 });
    await issOption.click();
    await page.waitForTimeout(2000); // Wait for satellite to be fully enabled

    // Also select Tiangong (second satellite)
    await searchInput.clear();
    await searchInput.pressSequentially("TIANGONG", { delay: 100 });
    await page.waitForTimeout(1500);

    const tiangongOption = page.locator('.multiselect__element').filter({
      hasText: /TIANGONG/i,
    }).first();

    if (await tiangongOption.isVisible({ timeout: 2000 }).catch(() => false)) {
      await tiangongOption.click();
      await page.waitForTimeout(2000);
    }

    // Close satellite menu by clicking menu button again
    await satelliteMenuButton.click();
    await page.waitForTimeout(500);

    // Step 2: Open satellite elements menu to toggle orbit visualization
    const satelliteElementsButton = page.locator('button[title="Satellite elements"]').or(
      page.locator('button.cesium-toolbar-button').filter({
        has: page.locator('[data-icon="layer-group"]'),
      }),
    ).first();

    await expect(satelliteElementsButton).toBeVisible({ timeout: 5000 });
    await satelliteElementsButton.click();
    await page.waitForTimeout(1000);

    // Wait for satellite elements menu to be visible
    await expect(page.locator('.toolbarSwitches:has-text("Satellite elements")')).toBeVisible({ timeout: 5000 });

    //Step 3: Test Orbit visualization with untracked satellites
    const orbitCheckbox = page.locator('input[type="checkbox"][value="Orbit"]');
    const orbitTrackCheckbox = page.locator('input[type="checkbox"][value="Orbit track"]');

    await expect(orbitCheckbox).toBeAttached({ timeout: 5000 });

    const orbitInitialState = await orbitCheckbox.isChecked();
    console.log(`\n=== TEST 1: Orbit toggle for UNTRACKED satellites ===`);
    console.log(`Orbit checkbox initial state: ${orbitInitialState ? "checked" : "unchecked"}`);

    // Get initial orbit state
    const initialOrbitState = await page.evaluate(() => {
      const hasOrbitPrimitive = !!window.cc?.sats?.satellites?.some(sat => sat?.components?.Orbit);
      const hasPathEntity = window.cc?.viewer?.entities?.values?.some(e => !!e.path) || false;
      return {
        hasOrbitPrimitive,
        hasPathEntity,
        hasOrbit: hasOrbitPrimitive || hasPathEntity,
        satelliteCount: window.cc?.sats?.satellites?.length || 0,
      };
    });

    console.log(`Initial state: ${JSON.stringify(initialOrbitState, null, 2)}`);

    // Use JavaScript evaluation to click hidden checkbox directly
    await orbitCheckbox.evaluate(node => node.click());
    expect(await orbitCheckbox.isChecked()).toBe(!orbitInitialState);

    // Wait for orbit path entities to be created (can take 3+ seconds)
    await page.waitForTimeout(3500);

    // Verify that orbit visualization was added to the Cesium viewer
    // Orbit can be rendered as either a PathGraphics entity OR a Primitive (depending on tracking state)
    const entityDataAfterToggle = await page.evaluate(() => {
      const viewer = window.cc?.viewer;
      if (!viewer) return { count: 0, entities: [], hasPath: false, hasOrbitPrimitive: false };

      const entities = viewer.entities.values.map(e => ({
        id: e.id,
        name: e.name,
        show: e.show,
        hasPolyline: !!e.polyline,
        hasPath: !!e.path,
      }));

      // Check if any entity has a path (PathGraphics)
      const hasPath = entities.some(e => e.hasPath);

      // Also check for orbit primitives (used for non-tracked satellites)
      // These are stored in the satellite component collection, not in entities
      const hasOrbitPrimitive = !!window.cc?.sats?.satellites?.some(sat => {
        return sat?.components?.Orbit;
      });

      return {
        count: entities.length,
        entities: entities,
        hasPath: hasPath,
        hasOrbitPrimitive: hasOrbitPrimitive,
        hasOrbit: hasPath || hasOrbitPrimitive,
      };
    });

    console.log(`Entity count after toggle: ${entityDataAfterToggle.count}`);
    console.log(`Has path entity: ${entityDataAfterToggle.hasPath}`);
    console.log(`Has orbit primitive: ${entityDataAfterToggle.hasOrbitPrimitive}`);
    console.log(`Has orbit (any type): ${entityDataAfterToggle.hasOrbit}`);
    console.log(`Entities after toggle:`, JSON.stringify(entityDataAfterToggle.entities, null, 2));

    // Verify that orbit visualization was created
    // NOTE: Orbit uses either PathGraphics (tracked satellite) or Primitive (untracked satellite)
    if (orbitInitialState) {
      // Was checked, now unchecked - orbit should be removed
      expect(entityDataAfterToggle.hasOrbit).toBe(false);
    } else {
      // Was unchecked, now checked - orbit should be created
      expect(entityDataAfterToggle.hasOrbit).toBe(true);
    }

    // Toggle back
    await orbitCheckbox.evaluate(node => node.click());
    await page.waitForTimeout(2000); // Wait for orbit entities to be removed
    expect(await orbitCheckbox.isChecked()).toBe(orbitInitialState);

    // Verify entity state returns to initial
    const finalEntityData = await page.evaluate(() => {
      const viewer = window.cc?.viewer;
      if (!viewer) return { count: 0, hasPath: false };

      const entities = viewer.entities.values;
      const hasPath = entities.some(e => !!e.path);

      return {
        count: entities.length,
        hasPath: hasPath,
      };
    });

    // Should match initial state
    if (orbitInitialState) {
      expect(finalEntityData.hasPath).toBe(true);
    } else {
      expect(finalEntityData.hasPath).toBe(false);
    }

    // Test Orbit track toggle
    await expect(orbitTrackCheckbox).toBeAttached({ timeout: 3000 });

    const trackInitialState = await orbitTrackCheckbox.isChecked();
    const trackInitialData = await page.evaluate(() => {
      const viewer = window.cc?.viewer;
      if (!viewer) return { count: 0, hasPath: false };

      const entities = viewer.entities.values;
      const hasPath = entities.some(e => !!e.path);

      return {
        count: entities.length,
        hasPath: hasPath,
      };
    });

    await orbitTrackCheckbox.evaluate(node => node.click());
    expect(await orbitTrackCheckbox.isChecked()).toBe(!trackInitialState);

    // Wait for orbit track path to be created (can take 3+ seconds)
    await page.waitForTimeout(3500);

    // Verify orbit track path entity was created/removed
    const trackDataAfterToggle = await page.evaluate(() => {
      const viewer = window.cc?.viewer;
      if (!viewer) return { count: 0, hasPath: false };

      const entities = viewer.entities.values;
      const hasPath = entities.some(e => !!e.path);

      return {
        count: entities.length,
        hasPath: hasPath,
      };
    });

    // Verify the path entity state changed
    expect(trackDataAfterToggle.hasPath).not.toBe(trackInitialData.hasPath);

    // Toggle back
    await orbitTrackCheckbox.evaluate(node => node.click());
    await page.waitForTimeout(2000);
    expect(await orbitTrackCheckbox.isChecked()).toBe(trackInitialState);

    const trackFinalData = await page.evaluate(() => {
      const viewer = window.cc?.viewer;
      if (!viewer) return { count: 0, hasPath: false };

      const entities = viewer.entities.values;
      const hasPath = entities.some(e => !!e.path);

      return {
        count: entities.length,
        hasPath: hasPath,
      };
    });

    // Should return to initial state
    expect(trackFinalData.hasPath).toBe(trackInitialData.hasPath);

    // Verify no errors occurred
    const errors = [];
    page.on("pageerror", (error) => errors.push(error));
    await page.waitForTimeout(500);
    expect(errors.length).toBe(0);
  });

  test("should handle component visibility toggles", async ({ page }) => {
    await page.goto("/?sat=25544");

    await expect(page.locator("#cesiumContainer canvas").first()).toBeVisible({ timeout: 15000 });

    await page.waitForTimeout(2000);

    // Look for component controls (Point, Label, etc.)
    const componentControls = page.locator('input[type="checkbox"]');

    const count = await componentControls.count();

    if (count > 0) {
      // Toggle first few components
      for (let i = 0; i < Math.min(count, 3); i++) {
        const control = componentControls.nth(i);
        if (await control.isVisible()) {
          await control.click();
          await page.waitForTimeout(200);
          await control.click();
          await page.waitForTimeout(200);
        }
      }

      // Verify canvas is still rendered
      await expect(page.locator("#cesiumContainer canvas").first()).toBeVisible();
    } else {
      test.skip();
    }
  });
});
